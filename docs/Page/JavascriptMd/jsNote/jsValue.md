# 值的比较

JavaScript在进行值比较是会把两侧的值转化为数字进行比较

。字符串是根据Unicode编码顺序进行，数字字符串直接转化为数字。空字符串为0，布尔类型，true为1，false为0。

## **需要注意的地方**

有时候，以下两种情况会同时发生：

- 若直接比较两个值，其结果是相等的。
- 若把两个值转为布尔值，它们可能得出完全相反的结果，即一个是 `true`，一个是 `false`。

例如：

```javascript
let a = 0;
alert( Boolean(a) ); // false

let b = "0";
alert( Boolean(b) ); // true

alert(a == b); // true!
```

JavaScript 会把待比较的值转化为数字后再做比较（因此 `"0"` 变成了 `0`）。若只是将一个变量转化为 `Boolean` 值，则会使用其他的类型转换规则。

## 严格的相等

普通的相等性检查 `==` 存在一个问题，它不能区分出 `0` 和 `false`：

```javascript
alert( 0 == false ); // true
```

也同样无法区分空字符串和 `false`：

```javascript
alert( '' == false ); // true
```

这是因为在比较不同类型的值时，处于相等判断符号 `==` 两侧的值会先被转化为数字。空字符串和 `false` 也是如此，转化后它们都为数字 0。

 **严格相等运算符 `===` 在进行比较时不会做任何的类型转换。** 

```javascript
alert( 0 === false ); // false，因为被比较值的数据类型不同
```

 与“不相等”符号 `!=` 类似，“严格不相等”表示为 `!==`。 

## 对null和undefined的比较

在严格相等下，它们不相等

```javascript
alert( null === undefined ); // false
```

 **当使用非严格相等** `==` **比较二者时** 

它们等于对方而不等于其他任何值 （只在非严格相等下成立）。 

```javascript
alert( null == undefined ); // true
```

## null  VS 0

通过比较 `null` 和 0 可得：

```javascript
alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) true
```

是的，上面的结果完全打破了你对数学的认识。在最后一行代码显示“`null` 大于等于 0”的情况下，前两行代码中一定会有一个是正确的，然而事实表明它们的结果都是 false。

为什么会出现这种反常结果，这是因为相等性检查 `==` 和普通比较符 `> < >= <=` 的代码逻辑是相互独立的。进行值的比较时，`null` 会被转化为数字，因此它被转化为了 `0`。这就是为什么（3）中 `null >= 0` 返回值是 true，（1）中 `null > 0` 返回值是 false。

另一方面，`undefined` 和 `null` 在相等性检查 `==` 中不会进行任何的类型转换，它们有自己独立的比较规则，

## undefined

 `undefined` 只与 `null` 相等，不会与其他值相等。 

在比较中undefined会转换为NaN， 而 `NaN` 是一个特殊的数值型值，它与任何值进行比较都会返回 `false`。 

## 总结

- 比较运算符始终返回布尔值。
- 字符串的比较，会按照“词典”顺序逐字符地比较大小。
- 当对不同类型的值进行比较时，它们会先被转化为数字（不包括严格相等检查）再进行比较。
- 在非严格相等 `==` 下，`null` 和 `undefined` 相等且各自不等于任何其他的值。
- 在使用 `>` 或 `<` 进行比较时，需要注意变量可能为 `null/undefined` 的情况。比较好的方法是单独检查变量是否等于 `null/undefined`。

